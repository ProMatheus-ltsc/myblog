# 用户模块管理
[[TOC]]
## 1. 前后端项目搭建


### 1.1 搭建后端项目

#### 1.1.1 创建项目

![在这里插入图片描述](https://img-blog.csdnimg.cn/0fe90abf8b97410cae6caecbf980ba25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 11.2 后端项目结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/6029b7f951604cae8cf4a1c3d45ed82f.png)

#### 1.1.3 导入项目

1. 导入pom.xml

```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!--mybatis依赖包-->
       <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.2.0</version>
        </dependency>

        <!--spring整合mybatis-plus -->
        <!-- <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.4.3</version>
        </dependency>-->

        <!--jdbc依赖包-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <!--添加lombok的包-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>
```

2. 导入src文件   [gitee地址](https://gitee.com/liulaoshi666/cgb2110/tree/master)

说明: 下载码云中的后端项目,导入src文件即可

![在这里插入图片描述](https://img-blog.csdnimg.cn/2145e870fcd34bce946f897b72ec0ea6.png)

3. 项目启动测试


   ![在这里插入图片描述](https://img-blog.csdnimg.cn/278b50feca694e4893b4f08ec1a019b7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

## 2. 用户登录实现

**需求**

模拟用户登录过程,利用[前后端分离](https://so.csdn.net/so/search?q=前后端分离&spm=1001.2101.3001.7020)的开发方式,完成项目练习

![在这里插入图片描述](https://img-blog.csdnimg.cn/b474f5dc243d451bb9143d3c58a06285.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2dibHB4,size_18,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/e983023ac72041e4914b69ec7a191dfc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2dibHB455qu55qu6Zye,size_16,color_FFFFFF,t_70,g_se,x_16)

### 2.1 项目准备工作

#### 2.1.1 user表说明

![在这里插入图片描述](https://img-blog.csdnimg.cn/12ccf05ab6b948c882e07cce68155dd3.png)

```sql
create database jt;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(80) DEFAULT NULL,
  `password` varchar(80) DEFAULT NULL,
  `phone` varchar(20) DEFAULT NULL,
  `email` varchar(40) DEFAULT NULL,
  `status` tinyint(1) DEFAULT NULL,
  `created` datetime DEFAULT NULL,
  `updated` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

insert  into `user`(`id`,`username`,`password`,`phone`,`email`,`status`,`created`,`updated`) values 
(1,'jack','202cb962ac59075b964b07152d234b70','13111112222','1235678@qq.com',1,'2021-02-18 19:17:23','2021-03-26 14:47:20'),
(2,'rose','250cf8b51c773f3f8dc8b4be867a9a02','13111112223','1235678@qq.com',1,'2021-02-18 19:17:23','2021-05-21 17:34:32'),
(4,'tony','81dc9bdb52d04dc20036dbd8313ed055','13111112222','11@qq.com',1,'2021-03-22 21:25:06','2021-03-22 21:25:06'),
(5,'test','e10adc3949ba59abbe56e057f20f883e','17688888888','527161772@qq.com',1,'2021-05-10 19:01:45','2021-05-10 19:01:45');

```



#### 2.1.2 编辑User POJO

**pojo是简单的Java对象，其中有一些属性及其getter setter方法的类，没有业务逻辑，有时可以作为VO**

1. 编辑父级POJO
   
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/8bd66b753177470cae39d0cd94737f00.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)
   
2. 编辑User 的POJO
   
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/02b257c5b30b414cb717422e712a7097.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

### 2.2 前后端项目说明

#### 2.2.1 前端项目

1. localhost:8000 是VUE UI客户端工具的路径
2. localhost:8080 是前端项目的路径
3. localhost:8091 是后端项目的路径

#### 2.2.2 前后端调用说明

![在这里插入图片描述](https://img-blog.csdnimg.cn/79969be3525247459fb9fd55a4ac7f90.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

### 2.3 用户登录实现

#### 2.3.1 创建VO-封装SysResult对象

**VO：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来，SysResult统一前后端数据交互的格式**

```java
package com.jt.vo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;

import java.io.Serializable;

@Data//动态生成get/set/toString方法
@Accessors(chain = true)//链式加载
@NoArgsConstructor//生成无参构造器
@AllArgsConstructor//生成全参构造器
public class SysResult implements Serializable {
    //响应登录请求的SysResult对象
    private Integer status; //200成功  201失败
    private String  msg;    //提示信息
    private Object  data;   //服务器返回值数据
/*
* 返回值格式
* {"status":200,"msg":"服务器调用成功!","data":"1e893a97634847b3a8b499b173bea620"}
* */
    public static SysResult fail(){

        return new SysResult(201,"业务调用失败!!",null);
    }

    public static SysResult success(){

        return new SysResult(200,"业务调用成功!!",null);
    }


    public static SysResult success(Object data){

        return new SysResult(200,"业务调用成功!!",data);
    }

    public static SysResult success(String msg,Object data){

        return new SysResult(200,msg,data);
    }
}

```

#### 2.3.2 业务接口文档

- 请求路径: /user/login
- 请求方式: POST
- 请求参数

| 参数名称 | 参数说明 | 备注     |
| -------- | -------- | -------- |
| username | 用户名   | 不能为空 |
| password | 密码     | 不能为空 |

- 响应数据 SysResult对象

| 参数名称 | 参数说明             | 备注                                    |
| -------- | -------------------- | --------------------------------------- |
| status   | 状态信息             | 200表示服务器请求成功 201表示服务器异常 |
| msg      | 服务器返回的提示信息 | 可以为null                              |
| data     | 服务器返回的业务数据 | 返回密钥token信息                       |

返回值格式如下:

```javascript
	{"status":200,"msg":"服务器调用成功!","data":"1e893a97634847b3a8b499b173bea620"}
```

#### 2.3.3 MD5加密算法

MD5信息**摘要算法**（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。
核心做法: 限定次数!!!

[MD5解密网站](https://cmd5.com/)

#### 2.3.4 编辑UserController

**Token：Token （令牌）是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的身份。如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。
使用token来标识当前用户，后端就能根据这个字段知道是哪个用户发起的请求了**

```java
package com.jt.controller;

import com.jt.pojo.User;
import com.jt.service.UserService;
import com.jt.vo.PageResult;
import com.jt.vo.SysResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.sql.SQLException;
import java.util.List;

@RestController//相当于Controller,每个方法上添加@ResponseBody
@RequestMapping("/user")//浏览器请求与方法的映射
@CrossOrigin    //前后端进行跨域操作
public class UserController {

    @Autowired//按照类型进行注入
    private UserService userService;

    @GetMapping("/findAll")//只能接收GET类型请求
    public List<User> findAll(){

        return userService.findAll();
    }

    /**
     * 业务需求: 实现用户登录操作
     * URL地址: /user/login
     * 请求类型: post
     * 参数:    username/password  json串
     * 返回值:  SysResult对象(token密钥)
     */
    @PostMapping("/login")//登录,拿着账号.密码查库,查到了就返回token,没查到就返回null,只接受POST请求类型
    public SysResult login(@RequestBody User user){

        String token = userService.login(user);
        //判断token是否为null
        if(token == null){
            return SysResult.fail(); //表示用户登录失败!!
        }
        return SysResult.success(token);//表示用户登录成功!!
    }

}
```

#### 2.3.5 编辑UserService

**MD5讯息摘要演算法（英语：MD5 Message-Digest Algorithm）, 一种被广泛使用的密码杂凑函数，可以产生出一个128位元（16位元组）的散列值（hash value）, 用于确保信息传输完整一致，（数字指纹）,MD5是不可逆的**

1. 编辑接口

```java
public interface UserService {

    List<User> findAll();

    String login(User user);
}
```

2. 编辑实现类

```java
@Service
public class UserServiceImpl implements UserService{

    @Autowired
    private UserMapper userMapper;

    @Override
    public List<User> findAll() {
        return userMapper.findAll();
    }

    /**
     * 业务思维能力: 用户登录操作
     * 登录业务逻辑:
     *      1.将用户的密码进行加密处理
     *      2.根据用户名和密码进行数据库查询
     *        查到了: 用户名和密码正确  返回token密钥
     *        没查到: 用户名和密码错误  返回null
     *
     * @param user
     * @return
     */
    //登录,拿着账号.密码查库,查到了就返回token,没查到就返回null
    //密码还要加密处理,要拿着用户的明文密码 加密后 和 库里加密密码 对比->加密算法:md5/sha/md5hash..
    @Override
    public String login(User user) {
        //1.将密码加密处理, 把明文密码获取出来,进行加密
        String password = user.getPassword();
        //把明文密码加密,利用MD5算法
        /*
            MD5讯息摘要演算法（英语：MD5 Message-Digest Algorithm），
            一种被广泛使用的密码杂凑函数，可以产生出一个128位元（16位元组）的散列值（hash value），
            用于确保信息传输完整一致。（数字指纹）,MD5是不可逆的
         */
        String md5Pass = DigestUtils.md5DigestAsHex(password.getBytes());
        user.setPassword(md5Pass);
        //2.根据用户名和密码查询数据库
        User userDB = userMapper.findUserByUP(user);
        if(userDB == null){
            //用户名或者密码错误
            return null;
        }
        //密钥:该密钥是用户登录的唯一的标识符,特点:独一无二
        String token = UUID.randomUUID().toString()
                        .replace("-", "");
        return token;//查到了,就返回一个token
    }
}
```

#### 2.3.6 编辑UserMapper

1. 编辑Mapper接口

```java
public interface UserMapper {

    List<User> findAll();//查找所有用户

    User findUserByUP(User user);//登录,根据账号密码查用户
}
```

2. 编辑xml映射文件

```xml
	<select id="findUserByUP" resultType="User">
        select * from user
            where username=#{username}
            and   password=#{password}
    </select>
```

#### 2.3.7 关于前后端报错说明

**模拟post请求**

```js
//方法一：
var url = "/dict/test";
var params = {advertiserUid: 1232131, advertiserWeiboNickname: "18"};
var xhr = new XMLHttpRequest();
xhr.open("POST", url, true);
xhr.setRequestHeader("Content-Type", "application/json");
xhr.onload = function (e) {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log(xhr.responseText);
    } else {
      console.error(xhr.statusText);
    }
  }
};
xhr.onerror = function (e) {
  console.error(xhr.statusText);
};
xhr.send(JSON.stringify(params));
 
//方法二：
var url = "/dict/test";
var params = "score=5&abc=6";
var xhr = new XMLHttpRequest();
xhr.open("POST", url, true);
xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 
xhr.onload = function (e) {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log(xhr.responseText);
    } else {
      console.error(xhr.statusText);
    }
  }
};
xhr.onerror = function (e) {
  console.error(xhr.statusText);
};
xhr.send(params);
```



1. 检查请求路径
   
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/be54c3b4f16446998a37d7cd561fda2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

2. 检查请求参数
   
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/177fd98ba46c4c2eaeb79f17471e554f.png)

3. 检查响应结果
   
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/2b84e2df12054321ad2bed3d0957e528.png)

### 2.4 关于前端路由说明

![在这里插入图片描述](https://img-blog.csdnimg.cn/9593254d05c64659b4461ba40e2404b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

### 2.5 左侧菜单列表展现

当完成用户登录后,继续完善系统的左侧菜单,展示一级二级目录

![在这里插入图片描述](https://img-blog.csdnimg.cn/e3c4f36b58b84722b2e669262345bf6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2dibHB4,size_16,color_FFFFFF,t_70,g_se,x_16)

#### 2.5.1 关于rights表说明

说明: 通过parent_id 控制父子关系.

![在这里插入图片描述](https://img-blog.csdnimg.cn/60c109544d514facb2de29e0a60ddebb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

```sql
#创建表
CREATE TABLE `rights` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(40) DEFAULT NULL,
  `parent_id` INT(11) DEFAULT NULL,
  `path` VARCHAR(50) DEFAULT NULL,
  `level` INT(11) DEFAULT NULL,
  `created` DATETIME DEFAULT NULL,
  `updated` DATETIME DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

#插入数据
INSERT  INTO `rights`(`id`,`name`,`parent_id`,`path`,`level`,`created`,`updated`) VALUES (1,'用户管理',0,NULL,1,'2021-02-18 19:17:23','2021-02-18 19:17:23'),(2,'用户列表',1,'/user',2,'2021-02-18 19:22:19','2021-02-18 19:22:19'),(3,'商品管理',0,NULL,1,'2021-02-18 19:22:41','2021-02-18 19:22:41'),(4,'商品列表',3,'/item',2,'2021-02-18 19:23:12','2021-02-18 19:23:12'),(6,'商品分类',3,'/itemCat',2,'2021-02-18 19:25:00','2021-02-18 19:25:00'),(7,'权限管理',0,'',1,'2021-02-18 19:23:44','2021-02-18 19:23:44'),(8,'数据统计',0,NULL,1,'2021-02-18 19:24:12','2021-02-18 19:24:12'),(9,'权限列表',7,'/rights',2,'2021-02-18 19:24:12','2021-02-18 19:24:12'),(10,'角色列表',7,'/role',2,'2021-02-18 19:24:12','2021-02-18 19:24:12'),(11,'用户列表-新增按钮',2,NULL,3,'2021-02-18 19:24:12','2021-02-18 19:24:12'),(12,'用户列表-修改按钮',2,NULL,3,'2021-02-18 19:24:12','2021-02-18 19:24:12'),(13,'用户列表-删除按钮',2,NULL,3,'2021-02-18 19:24:12','2021-02-18 19:24:12'),(15,'统计报表',8,'/report',2,'2021-02-18 19:24:12','2021-02-18 19:24:12');


```



#### 2.5.2 编辑Rights POJO

**pojo是简单的Java对象，其中有一些属性及其getter setter方法的类，没有业务逻辑，有时可以作为VO**

```java
//权限封装
@TableName
@Data//动态生成get/set/toString方法
@Accessors(chain = true)//链式加载结构
public class Rights extends BasePojo{
    private Integer id;
    private String name;
    private Integer parentId;
    private String path;
    @TableField(exist = false)
    private List<Rights> children;//一对多,不是表格固有属性,存二级菜单
}
```

#### 2.5.3 搭建层级代码结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/19606668cfa74f959a792bc11c739bbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_15,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/6bf75e0623784c96ad840ba72011059a.png)

#### 2.5.4 业务接口

- 请求路径 /rights/getRightsList
- 请求类型 GET
- 请求参数 无
- 响应数据 SysResult对象

| 参数名称 | 参数说明             | 备注                                    |
| -------- | -------------------- | --------------------------------------- |
| status   | 状态信息             | 200表示服务器请求成功 201表示服务器异常 |
| msg      | 服务器返回的提示信息 | 可以为null                              |
| data     | 服务器返回的业务数据 | 返回权限List集合                        |

- 响应数据如图所示 只查询1-2级数据
  
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210512213439727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2ODA0ODQ3,size_16,color_FFFFFF,t_70)

##### 修改pom.xml

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-annotation</artifactId>
    <version>3.4.2</version>
</dependency>
```

#### 2.5.5 编辑RightsController

```java
package com.jt.controller;

import com.jt.pojo.Rights;
import com.jt.service.RightsService;
import com.jt.vo.SysResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@CrossOrigin
@RequestMapping("/rights")
public class RightsController {

    @Autowired
    private RightsService rightsService;

    /**
     * url地址: /rights/getRightsList
     * 参数:  没有参数
     * 请求类型: get
     * 返回值: SysResult(List<Rights>) 1-2级
     */
    @GetMapping("/getRightsList")
    public SysResult getRightsList(){
        //获取权限列表

        List<Rights> list = rightsService.getRightsList();
        System.out.println(list);
        return SysResult.success(list);
    }

}
```

#### 2.5.6 编辑RightsService

1. 编辑接口

```java
package cn.tedu.service;

import cn.tedu.pojo.Rights;

import java.util.List;

public interface RightsService {
    List<Rights> getRightsList(); //获取权限列表
}

```

2.编辑实现类

```java
package com.jt.service;

import com.jt.mapper.RightsMapper;
import com.jt.pojo.Rights;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class RightsServiceImpl implements RightsService{

    @Autowired
    private RightsMapper rightsMapper;

    /**
     * 难点: 查询1-2级的菜单,一级对象中包含二级对象
     * 操作:
     *      1.简单程度  在业务层查询多次手动封装  效率低
     *      2.正常方式  利用Sql进行关联查询      效率高
     * @return
     */
    @Override
    public List<Rights> getRightsList() {

        return rightsMapper.getRightsList();
    }
}

```

#### 2.5.7 编辑RightsMapper

1. 编辑Mapper接口

```java
public interface RightsMapper {

    List<Rights> getRightsList();//获取权限列表
}
```

2. 编辑Xml映射文件

```xml
<mapper namespace="com.jt.mapper.RightsMapper">

    <!--查询1-2级的关联数据-->
    <select id="getRightsList" resultMap="rightsRM">
        SELECT p.*,c.id c_id,c.name c_name,c.parent_id c_parent_id,
               c.path c_path,c.level c_level,c.created c_created,
               c.updated c_updated
        FROM rights p,rights c
        WHERE p.level=1 AND c.parent_id = p.id
    </select>
    <!--开启自动映射,驼峰规则-->
    <resultMap id="rightsRM" type="Rights" autoMapping="true">
        <!--主键-->
        <id column="id" property="id"/>

        <!--关联封装
            columnPrefix="指定字段映射的前缀"
        -->
        <!--单独配置一对多的属性children-->
        <collection property="children" ofType="Rights" autoMapping="true" columnPrefix="c_">
            <!--主键必须标识-->
            <id column="id" property="id"/>
           <!-- <result column="c_name" property="name"/>
            <result column="c_parent_id" property="parentId"/>
            <result column="c_path" property="path"/>
            <result column="c_level" property="level"/>
            <result column="c_created" property="created"/>
            <result column="c_updated" property="updated"/>-->
        </collection>
    </resultMap>
     <select id="getRightsList" resultMap="rightsRM">
        /* 查一级菜单的子级:两种方式效果相同
            select * from rights p left join rights c
            where p.id=c.parent_id
            and p.parent_id=0
       */
       /* 存在大量重复的字段名,需用改名
            select * from
            ( select * from rights where parent_id=0 ) p left join rights c
            where p.id=c.parent_id
       */
        SELECT * FROM
        (SELECT * FROM rights a WHERE a.`parent_id`=0 )p  /*查一级*/
        LEFT JOIN /*关联查二级*/
        (SELECT id cid,NAME cname,parent_id cparentid,path cpath,LEVEL clevel,created ccreated,updated cupdated FROM rights) c
        ON p.id=c.cparentid /*用别名*/
    </select>

</mapper>
```

#### 2.5.8 页面效果展现

启动Vue项目，输入正确的用户名密码，直接登录，登录成功后，可以看到左侧菜单，就说明查询成功啦。

![在这里插入图片描述](https://img-blog.csdnimg.cn/318d44d987d3416b8b01561bb50e1207.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

## 3. 配置路由

### 3.1 路由规则

1. 定义路由占位符
   
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/cbacc8b4301b4021a9821715724d8730.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

2. 定义路由规则
   通过children关键字,实现父子组件的定义

```javascript
const routes = [
  {path: '/', redirect: '/login'},
  {path: '/login', component: Login},
  {path: '/elementUI', component: ElementUI},
  {path: '/home', component: Home, children:[
    {path: '/user', component: User},
    {path: '/item', component: Item},
    {path: '/itemCat', component: ItemCat}
  ]},
]
```

## 4. 用户模块管理

### 4.1 用户列表展现

##### 项目结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/79db965048a043ae9dd8daeb871fbaee.png)

##### 创建pojo层 - PageResult类

封装了分页信息,包括分页的查询条件,和查到的数据等.

```java
package cn.tedu.pojo;

import lombok.Data;
import lombok.experimental.Accessors;
import java.io.Serializable;

@Data
@Accessors(chain = true)
public class PageResult implements Serializable {
    private String query;//查询条件
    private Integer pageNum;//查询页数
    private Integer pageSize;//一次要查询条数
    private Long total;//查询总记录数
    private Object rows;//分页的结果
}
```

#### 4.1.1 接口文档说明

- 请求路径: /user/list
- 请求类型: GET
- 请求参数: 后台使用PageResult对象接收
- 请求案例: http://localhost:8091/user/list?query=查询关键字&pageNum=1&pageSize=10

| 参数名称 | 参数说明       | 备注信息           |
| -------- | -------------- | ------------------ |
| query    | 用户查询的数据 | 可以为null         |
| pageNum  | 分页查询的页数 | 必须赋值不能为null |
| pageSize | 分页查询的条数 | 必须赋值不能为null |

- 响应参数: SysResult对象 需要携带分页对象 PageResult

| 参数名称 | 参数说明             | 备注信息                                |
| -------- | -------------------- | --------------------------------------- |
| status   | 状态信息             | 200表示服务器请求成功 201表示服务器异常 |
| msg      | 服务器返回的提示信息 | 可以为null                              |
| data     | 服务器返回的业务数据 | 返回值PageResult对象                    |

- PageResult 对象介绍

| 参数名称 | 参数类型 | 参数说明       | 备注信息   |
| -------- | -------- | -------------- | ---------- |
| query    | String   | 用户查询的数据 | 可以为null |
| pageNum  | Integer  | 查询页数       | 不能为null |
| pageSize | Integer  | 查询条数       | 不能为null |
| total    | Long     | 查询总记录数   | 不能为null |
| rows     | Object   | 分页查询的结果 | 不能为null |

- 返回值效果

```json
{"status":200,
  "msg":"服务器调用成功!",
  "data":
	{"query":"",
	"pageNum":1,
	"pageSize":2,
	"total":4,
	"rows":[
		{"created":"2021-02-18T11:17:23.000+00:00",
		 "updated":"2021-03-26T06:47:20.000+00:00",
		 "id":1,
		 "username":"admin",
		 "password":"a66abb5684c45962d887564f08346e8d",
		 "phone":"13111112222",
		 "email":"1235678@qq.com",
		 "status":true,
		 "role":null
		 },
		{"created":"2021-02-18T11:17:23.000+00:00",
		"updated":"2021-03-13T08:50:30.000+00:00",
		"id":2,
		"username":"admin123",
		"password":"a66abb5684c45962d887564f08346e8d",
		"phone":"13111112223",
		"email":"1235678@qq.com",
		"status":false,
		"role":null
		}
		]
	}
}
```

#### 4.1.2 分页语法结构

```sql
/*每页10条   查询第一页
 select * from user limit 起始位置,查询条数
 规律: 数组含头不含尾*/
SELECT * FROM USER LIMIT 0,10
/*第二页*/
SELECT * FROM USER LIMIT 10,10
/*第三页*/
SELECT * FROM USER LIMIT 20,10
/*第N页*/
SELECT * FROM USER LIMIT (n-1)*10,10
```

#### 4.1.3 编辑UserController

```java
 /**
     * 业务需求: 分页查询用户数据
     * URL: /user/list
     * 类型: GET类型
     * 参数: pageResult接收
     *      http://localhost:8091/user/list?query=查询关键字&pageNum=1&pageSize=10
     * 返回值: SysResult(PageResult对象)
     */
    @GetMapping("/list")
    public SysResult findList(PageResult pageResult){//3

        pageResult = userService.findList(pageResult); //3+2 总数+分页结果,根据分页条件,查询分页数据
        return SysResult.success(pageResult);//5,把分页数据传递给前端
    }
```

#### 4.1.4 编辑UserService

1. 编辑UserService接口

```java
	PageResult findList(PageResult pageResult);
//查分页,携带着参数来请求数据,要从第几条开始查,一共要查几条


```

2. 编辑UserServiceImpl

```java
@Override
    public PageResult findList(PageResult pageResult) {
        //1.获取记录总数
        long total = userMapper.findCount();
        //2.获取分页结果
        //第一页: limit 0,10  第二页: limit 10,10  第三页:limit 30,10  第n页:limit (n-1)*10,10
        int size = pageResult.getPageSize(); //条数
        int start = (pageResult.getPageNum() - 1) * size; //起始位置
        String query = pageResult.getQuery();   //查询条件
        //查询分页结果,根据分页条件,查询分页的数据,自己算位置
        List<User> list = userMapper.findUserLimit(query,start,size);
        //封装返回值数据
        pageResult.setTotal(total).setRows(list);
        return pageResult; //3+2的效果!!
    }
```

#### 4.1.5 编辑UserMapper

1. 编辑Mapper接口

```java
 	//根据分页条件,查询分页的数据,多个数据,进行封装
    //@Param是为了传递多个参数，解决的是可读性和直观性,会自动把参数封装成map结构,key就是括号里的值,value就是变量名
    //@Param和@RequestParam是什么关系？雷锋和雷锋塔的关系,没关系
List<User> findUserLimit(@Param("query") String query,
                             @Param("start") int start,
                             @Param("size") int size);
```

2. 编辑xml映射文件

```xml
  <select id="findUserLimit" resultType="User">
        select * from user
            <where>
                <if test="query !=null and query !=''">username like "%"#{query}"%"</if>
            </where>
            limit #{start},#{size}
    </select>
 <!--如果携带着请求参数,就去获取mapper层传来的参数-->
<!--分页查询,参数动态从mapper层传来的参数获取-->
```

#### 4.1.6 页面效果展现

![在这里插入图片描述](https://img-blog.csdnimg.cn/39efc9a513b44ecbaf9601bdd668a1c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

### 4.2 用户状态修改

#### 4.2.1 接口文档

- 请求路径 /user/status/{id}/{status}
- 请求类型 PUT
- 请求参数: 用户ID/状态值数据

| 参数名称 | 参数类型 | 参数说明     | 备注信息   |
| -------- | -------- | ------------ | ---------- |
| id       | Integer  | 用户ID号     | 不能为null |
| status   | boolean  | 参数状态信息 | 不能为null |

- 返回值结果: SysResult对象

```json
{"status":200,"msg":"服务器调用成功!","data":null}
```

#### 4.2.2 编辑UserController

```java
 /**
     *  - 请求路径 /user/status/{id}/{status}
     *  - 请求类型	PUT
     *  - 请求参数: 	用户ID/状态值数据
     *  - 返回值:  SysResult
     */
    @PutMapping("/status/{id}/{status}")
    public SysResult updateStatus(User user){

        userService.updateStatus(user);
        return SysResult.success();
    }
```

#### 4.2.3 编辑UserService

1. 编辑UserService

```java
	void updateStatus(User user);
```

2. 编辑UserServiceImpl

```java
 @Override
    @Transactional  //控制事务
    public void updateStatus(User user) {
        //获取当前时间
        user.setUpdated(new Date());
        userMapper.updateStatus(user);
    }
```

#### 4.2.4 编辑UserMapper

```java
 @Update("update user set status=#{status},updated=#{updated} where id=#{id}")
 void updateStatus(User user);
```

### 4.3 用户删除操作

#### 4.3.1 业务接口

- 请求路径: /user/{id}
- 请求类型: delete
- 请求参数:

| 参数名称 | 参数说明 | 备注       |
| -------- | -------- | ---------- |
| ID       | 用户ID号 | 不能为null |

- 返回值: SysResult对象

| 参数名称 | 参数说明             | 备注                                    |
| -------- | -------------------- | --------------------------------------- |
| status   | 状态信息             | 200表示服务器请求成功 201表示服务器异常 |
| msg      | 服务器返回的提示信息 | 可以为null                              |
| data     | 服务器返回的业务数据 | null                                    |

#### 4.3.2 编辑UserController

```java
/**
     * 业务说明: 删除业务
     * 请求路径: /user/{id}
     * 请求类型: delete
     * 请求参数: id=xx
     * 返回值: SysResult对象
     */
    @DeleteMapping("/{id}")
    public SysResult deleteUser(@PathVariable Integer id){

        userService.deleteUserById(id);
        return SysResult.success();
    }
```

#### 4.3.3 编辑UserService

1. 编辑UserService接口

```java
 void deleteUserById(Integer id);
```

2. 编辑UserServiceImpl

```java
@Override
    @Transactional  //控制事务
    public void deleteUserById(Integer id) {

        userMapper.deleteUserById(id);
    }
```

#### 4.3.4 编辑UserMapper

```java
 @Delete("delete from user where id=#{id}")
 void deleteUserById(Integer id);
```

#### 4.3.5 关于删除操作bug说明

bug: 漏洞 一般条件下对的,偶然现象可能导致错误.
说明: 添加return 关键字即可.

![在这里插入图片描述](https://img-blog.csdnimg.cn/be8059e1de2748cf9d8c6b56943bf6e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zeq6ICA5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16)

### 4.4 用户新增操作

#### 4.4.1 业务接口文档

- 请求路径 /user/addUser
- 请求类型 POST
- 请求参数: 整个form表单数据封装为js对象进行参数传递

| 参数名称 | 参数类型 | 参数说明 | 备注信息   |
| -------- | -------- | -------- | ---------- |
| username | String   | 用户名   | 不能为null |
| password | String   | 密码     | 不能为null |
| phone    | String   | 电话号码 | 不能为null |
| email    | String   | 密码     | 不能为null |

- 返回值结果: SysResult对象

```json
{"status":200,"msg":"服务器调用成功!","data":null}
```

#### 4.4.2 编辑UserController

```java
/**
     * 业务说明: 用户新增
     * 请求路径 /user/addUser
     * 请求类型 POST
     * 请求参数: 整个form表单数据封装为js对象进行参数传递
     * 返回值结果: SysResult对象
     */
    @PostMapping("/addUser")
    public SysResult addUser(@RequestBody User user){

        userService.addUser(user);
        return SysResult.success(); //200
    }
```

#### 4.4.3 编辑UserService

1. 编辑UserService接口

```java
 void addUser(User user);
```

2. 编辑UserServiceImpl实现类

```java
@Override
    @Transactional
    public void addUser(User user) {
        Date date = new Date(); //获取当前时间
        String md5Pass =
                DigestUtils.md5DigestAsHex(user.getPassword().getBytes());
        user.setPassword(md5Pass)
            .setStatus(true)
            .setCreated(date)
            .setUpdated(date);
        userMapper.addUser(user);
    }
```

#### 4.4.4 编辑UserMapper

1. 编辑UserMapper接口

```java
 void addUser(User user);
```

2. 编辑UserMapper.xml映射文件

```xml
<!--完成用户入库操作-->
    <insert id="addUser">
        insert into user values (null,#{username},#{password},#{phone},#{email},#{status},#{created},#{updated})
    </insert>
```

### 4.5 用户更新操作-回显

#### 4.5.1 业务接口文档

- 请求路径: /user/{id}
- 请求类型: GET
- 返回值: SysResult对象

| 参数名称 | 参数说明             | 备注                                    |
| -------- | -------------------- | --------------------------------------- |
| status   | 状态信息             | 200表示服务器请求成功 201表示服务器异常 |
| msg      | 服务器返回的提示信息 | 可以为null                              |
| data     | 服务器返回的业务数据 | 返回user对象                            |

- JSON格式如下:

```json
{
 "status":200,
 "msg":"服务器调用成功!",
 "data":{
	 "created":"2021-02-18T11:17:23.000+00:00",
	 "updated":"2021-05-17T11:33:46.000+00:00",
	 "id":1,
	 "username":"admin",
	 "password":"a66abb5684c45962d887564f08346e8d",
	 "phone":"13111112222",
	 "email":"1235678@qq.com",
	 "status":true,
	 "role":null
	 }
 }
```

#### 4.5.2 编辑UserController

```java
 /**
     * 业务说明:
     *  请求路径: /user/{id}
     *  请求类型: GET
     *  返回值: SysResult(User对象)
     */
    @GetMapping("/{id}")
    public SysResult findUserById(@PathVariable Integer id){

        User user = userService.findUserById(id);
        return SysResult.success(user);
    }
```

#### 4.5.3 编辑UserService

1. 编辑UserService接口

```java
	User findUserById(Integer id);
```

2. 编辑UserServiceImpl实现类

```java
 	@Override
    public User findUserById(Integer id) {

        return userMapper.findUserById(id);
    }
```

#### 4.5.4 编辑UserMapper

```java
 @Select("select * from user where id=#{id}")
 User findUserById(Integer id);
```

### 4.6 用户更新操作-更新

#### 4.6.1 业务接口说明

- 请求路径: /user/updateUser
- 请求类型: PUT
- 请求参数: User对象结构

| 参数名称 | 参数说明 | 备注       |
| -------- | -------- | ---------- |
| ID       | 用户ID号 | 不能为null |
| phone    | 手机信息 | 不能为null |
| email    | 邮箱地址 | 不能为null |

- 返回值: SysResult对象

| 参数名称 | 参数说明             | 备注                                    |
| -------- | -------------------- | --------------------------------------- |
| status   | 状态信息             | 200表示服务器请求成功 201表示服务器异常 |
| msg      | 服务器返回的提示信息 | 可以为null                              |
| data     | 服务器返回的业务数据 | null                                    |

- JSON格式如下:

```json
{
 "status":200,
 "msg":"服务器调用成功!",
 "data":{}
 }
```

#### 4.6.2 编辑UserController

```java
 /**
     * 完成用户更新操作
     * 请求路径: /user/updateUser
     * 请求类型: PUT
     * 请求参数: User对象结构
     */
    @PutMapping("/updateUser")
    public SysResult updateUser(@RequestBody User user){

        userService.updateUser(user);
        return SysResult.success();
    }
```

#### 4.6.3 编辑UserService

1. 编辑UserService

```java
void updateUser(User user);
```

2. 编辑UserServiceImpl

```java
 //电话/邮箱/更新时间 where id=xx
    @Override
    @Transactional
    public void updateUser(User user) {

       user.setUpdated(new Date());
       userMapper.updateUser(user);
    }
```

#### 4.6.4 编辑UserMapper

```java
 @Update("update user set phone=#{phone},email=#{email},updated=#{updated} " +
            "where id=#{id}")
 void updateUser(User user);
```

### 4.7 全局异常处理机制

#### 4.7.1 现象描述

由于后端服务器只是处理了200的正确的请求,如果后端服务器报错了,理论上应该返回201提示信息. 这样前端接收到201提示之后 给用户反馈. 这样的用户体验更好.
问题: 几乎所有的业务都需要防止异常的发生. 所有的方法都必须有201的判断. 代码如图所示

案例:

```java
	@PutMapping("/updateUser")
    public SysResult updateUser(@RequestBody User user){
        try{
            userService.updateUser(user);
            return SysResult.success();
        }catch (Exception e){
            e.printStackTrace(); //打印异常
            return SysResult.fail();
        }
    }
```

解决方案: Spring-AOP 面向切面编程

#### 4.7.2 全局异常处理机制

```java
package com.jt.aop;

import com.jt.vo.SysResult;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

//Spring专门为解决异常问题,开发了针对Controller层的注解
//注解的核心就是 Spring-AOP
@RestControllerAdvice
public class SystemException {

    /**
     * 拦截什么异常: 运行时异常
     * 返回值: SysResult对象 --201
     * @ExceptionHandler: 切入点表达式
     */
    @ExceptionHandler(RuntimeException.class)
    public SysResult fail(Exception e){
        e.printStackTrace();
        return SysResult.fail();
    }
}
```