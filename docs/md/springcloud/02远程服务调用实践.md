# 远程服务调用实践
[[TOC]]


## 服务负载均衡设计及实现（重点）

### 业务描述

一个服务实例可以处理请求是有限的,假如服务实例的并发访问比较大,我们会启动多个服务实例,让这些服务实例采用一定策略均衡(轮询,权重,随机,hash等)的处理并发请求,在Nacos中服务的负载均衡(Nacos客户端负载均衡)是如何应用的?

### LoadBalancerClient应用

LoadBalancerClient对象可以从nacos中基于服务名获取服务实例，然后在工程中基于特点算法实现负载均衡方式的调用，案例实现如下：

第一步:修改ConsumerController类,注入LoadBalancerClient对象,并添加doRestEcho2方法,然后进行服务访问.

```java
  @Autowired
  private LoadBalancerClient loadBalancerClient;
  
  @Value("${spring.application.name:8090}")
  private String appName;
   
  @GetMapping("/consumer/doRestEcho02")
 public String doRestEcho02(){
     ServiceInstance serviceInstance = loadBalancerClient.choose("sca-provider");
     String url = String.format("http://%s:%s/provider/echo/%s",serviceInstance.getHost(),serviceInstance.getPort(),appName);
     System.out.println("request url:"+url);
     return restTemplate.getForObject(url, String.class);
     }
 }
```

第二步：打开Idea服务启动配置，如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/fd5b4ccc3ed64e3f9db36562548fd02e.png)

第三步：修改并发运行选项(假如没有找到这个选项我们需要通过搜索引擎基于组合查询的方法,去找到对应的解决方案,例如搜索 idea allow parallel run)，如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/ebc34033e3674449b6f9d5da153a469d.png)

第四步：修改sca-provider的配置文件端口，分别以8081，8082端口方式进行启动。

```yaml
server:
  port: 8082
spring:
  application:
    name: sca-provider
  cloud:
    nacos:
      server-addr: localhost:8848
```

第五步：启动成功以后，访问nacos的服务列表，检测服务是否成功注册，如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/61f5fe11dbe74d0088bad185a8b25b37.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/50a56d6d947e4b18a0adec0ba867f4a7.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/efb6499e92904cbea7653f61082e639b.png)

第六步：启动sca-consumer项目模块，打开浏览器对consumer服务进行访问，访问时不断刷新，检测页面数据变化。

说明，这里多个实例并发提供服务的方式为负载均衡，这里的负载均衡实现默认是因为Nacos集成了Ribbon来实现的，Ribbon配合RestTemplate，可以非常容易的实现服务之间的访问。Ribbon是Spring Cloud核心组件之一，它提供的最重要的功能就是客户端的负载均衡(客户端可以采用一定算法,例如轮询访问，访问服务端实例信息)，这个功能可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡方式的服务调用。

### @LoadBalanced

当使用RestTemplate进行远程服务调用时，假如需要负载均衡,还可以在RestTemplate对象构建时，使用@LoadBalanced对构建RestTemplate的方法进行修饰，例如在ConsumerApplication中构建名字为loadBalancedRestTemplate的RestTemplate对象：

```java
@Bean
@LoadBalanced
public RestTemplate loadBalancedRestTemplate(){
    return new RestTemplate();
}
```

在需要RestTemplate实现负载均衡调用的地方进行依赖注入.例如在ConsumerController类中添加loadBalancedRestTemplate属性

```java
@Autowired
private RestTemplate loadBalancedRestTemplate;
```

接下来，可以在对应的服务端调用方的方法内，基于RestTemplate借助服务名进行服务调用， 例如：

```java
@GetMapping("/consumer/doRestEcho3")
public String doRestEcho03(){
    String url=String.format("http://%s/provider/echo/%s","sca-provider",appName);
    //向服务提供方发起http请求,获取响应数据
    return loadBalancedRestTemplate.getForObject(
            url,//要请求的服务的地址
            String.class);//String.class为请求服务的响应结果类型
}
```

RestTemplate在发送请求的时候会被LoadBalancerInterceptor拦截，它的作用就是用于RestTemplate的负载均衡，LoadBalancerInterceptor将负载均衡的核心逻辑交给了loadBalancer，核心代码如下所示(了解):

```java
public ClientHttpResponse intercept(final HttpRequest request, 
    final byte[] body, final ClientHttpRequestExecution execution) throws IOException {
	final URI originalUri = request.getURI();
	String serviceName = originalUri.getHost();
	return this.loadBalancer.execute(serviceName, 
    requestFactory.createRequest(request, body, execution));
}
```

@LoadBalanced注解是属于Spring，而不是Ribbon的，Spring在初始化容器的时候，如果检测到Bean被@LoadBalanced注解，Spring会为其设置LoadBalancerInterceptor的拦截器。

### Ribbon负载均衡策略(了解)

基于Ribbon方式的负载均衡，Netflix默认提供了七种负载均衡策略，对于SpringCloud Alibaba解决方案中又提供了NacosRule策略，默认的负载均衡策略是轮训策略。如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/fb4e370978ad467b90ea81ca176f179e.png)

当系统提供的负载均衡策略不能满足我们需求时，我们还可以基于IRule接口自己定义策略.

### 小节面试分析

- @Bean注解的作用?(一般用于配置类内部,描述相关方法,用于告诉spring此方法的返回值要交给spring管理,bean的名字默认为方法名,假如需要指定名字可以@Bean(“bean的名字”),最多的应用场景是整合第三方的资源-对象)
- @Autowired注解的作用?(此注解用于描述属性,构造方法,set方法等,用于告诉spring框架,按找一定的规则为属性进行DI操作,默认按属性,方法参数类型查找对应的对象,假如只找到一个,则直接注入,类型多个时还会按照属性名或方法参数名进行值的注入,假如名字也不同,就出报错.)
- Nacos中的负责均衡底层是如何实现的?(通过Ribbon实现,Ribbon中定义了一些负载均衡算法,然后基于这些算法从服务实例中获取一个实例为消费方法提供服务)
- Ribbon 是什么？(Netflix公司提供的负载均衡客户端,一般应用于服务的消费方法)
- Ribbon 可以解决什么问题? (基于负载均衡策略进行服务调用, 所有策略都会实现IRule接口)
- Ribbon 内置的负载策略都有哪些?(8种,可以通过查看IRule接口的实现类进行分析)
- @LoadBalanced的作用是什么？(描述RestTemplate对象,用于告诉Spring框架，在使用RestTempalte进行服务调用时，这个调用过程会被一个拦截器进行拦截,然后在拦截器内部,启动负载均衡策略。)
- 我们可以自己定义负载均衡策略吗？(可以，基于IRule接口进行策略定义,也可以参考NacosRule进行实现)

## 基于Feign的远程服务调用（重点）

### 背景分析

服务消费方基于rest方式请求服务提供方的服务时，一种直接的方式就是自己拼接url，拼接参数然后实现服务调用，但每次服务调用都需要这样拼接，代码量复杂且不易维护，此时Feign诞生。

### Feign是什么

Feign 是一种声明式Web服务客户端，底层封装了对Rest技术的应用,通过Feign可以简化服务消费方对远程服务提供方法的调用实现。如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/163741e4cff44e7aa714bb003c9b2672.png)

Feign 最早是由 Netflix 公司进行维护的，后来 Netflix 不再对其进行维护，最终 Feign 由一些社区进行维护，更名为 OpenFeign。

### Feign应用实践（掌握）

第一步：在服务消费方，添加项目依赖(SpringCloud团队基于OpenFeign研发了starter)，代码如下：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

第二步：在启动类上添加@EnableFeignClients注解，代码如下：

```java
@EnableFeignClients
@SpringBootApplication
public class ConsumerApplication {…}
```

第三步：定义Http请求API，基于此API借助OpenFeign访问远端服务，代码如下：

```java
package com.jt.consumer.service;
@FeignClient(name="sca-provider")//sca-provider为服务提供者名称
public interface RemoteProviderService{
    @GetMapping("/provider/echo/{string}")//前提是远端需要有这个服务
    public String echoMessage(@PathVariable("string") String string);
}
```

其中，@FeignClient描述的接口底层会为其创建实现类。

第四步：创建FeignConsumerController中并添加feign访问，代码如下：

```java
package com.jt.consumer.controller;
@RestController
@RequestMapping("/consumer/ ")
public class FeignConsumerController {
    @Autowired
    private RemoteProviderService remoteProviderService;
    /**基于feign方式的服务调用*/
    @GetMapping("/echo/{msg}")
    public String doFeignEcho(@PathVariable  String msg){
        //基于feign方式进行远端服务调用(前提是服务必须存在)
        return remoteProviderService.echoMessage(msg);
    }
}
```

第五步：启动消费者服务，在浏览器中直接通过feign客户端进行访问，如图所示（反复刷新检测其响应结果）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/d89e1e76746141a6bab78830a82af589.png)

说明，feign方式的远程服务调用，底层会自动基于ribbon组件实现负载均衡。

### Feign配置进阶实践

一个服务提供方通常会提供很多资源服务,服务消费方基于同一个服务提供方写了很多服务调用接口,此时假如没有指定contextId,服务
启动就会失败,例如，假如在服务消费方再添加一个如下接口,消费方启动时就会启动失败,例如:

```java
 @FeignClient(name="sca-provider")
 public interface RemoteOtherService {
     @GetMapping("/doSomeThing")
     public String doSomeThing();
}
```

其启动异常如下：

```java
The bean 'optimization-user.FeignClientSpecification', defined in null, could not be registered. A bean with that name has already been defined in null and overriding is disabled.
```

此时我们需要为远程调用服务接口指定一个contextId,作为远程调用服务的唯一标识（这个标识是Bean对象的名字）即可,例如:

```java
@FeignClient(name="sca-provider",contextId="remoteProviderService")//sca-provider为服务提供者名称
interface RemoteProviderService{
    @GetMapping("/provider/echo/{string}")//前提是远端需要有这个服务
    public String echoMessage(@PathVariable("string") String string);
}
```

还有,当我们在进行远程服务调用时,假如调用的服务突然不可用了或者调用过程超时了,怎么办呢?一般服务消费端会给出具体的容错方案,例如，在Feign应用中通过FallbackFactory接口的实现类进行默认的相关处理，例如:

第一步:定义FallbackFactory接口的实现,代码如下:

```java
package com.jt.service.factory;
/**
 * 基于此对象处理RemoteProviderService接口调用时出现的服务中断,超时等问题
 */
@Component
public class ProviderFallbackFactory implements FallbackFactory<RemoteProviderService> {
    /**
     * 此方法会在RemoteProviderService接口服务调用时,出现了异常后执行.
     * @param throwable 用于接收异常
     */
    @Override
    public RemoteProviderService create(Throwable throwable) {
        return (msg)->{
                return "服务维护中,稍等片刻再访问";
        };
    }
}
```

第二步:在Feign访问接口中应用FallbackFactory对象,例如:

```java
@FeignClient(name = "sca-provider", contextId = "remoteProviderService",
             fallbackFactory = ProviderFallbackFactory.class)//sca-provider为nacos中的服务名
public interface RemoteProviderService {
    @GetMapping("/provider/echo/{msg}")
    public String echoMsg(@PathVariable String msg);
}
```

第三步:在配置文件application.yml中添加如下配置,启动feign方式调用时的服务中断处理机制.

```yml
feign:  
  hystrix:
    enabled: true #默认值为false
```

第四步:在服务提供方对应的调用方法中添加Thread.sleep(5000)模拟耗时操作,然后启动服务进行访问测试.

### Feign 调用过程分析（了解）

Feign应用过程分析（底层逻辑先了解）：

1)通过 @EnableFeignCleints 注解告诉springcloud,启动 Feign Starter 组件。

1) Feign Starter 会在项目启动过程中注册全局配置，扫描包下所由@FeignClient注解描述的接口，然后由系统底层创建接口实现类(JDK代理类)，并构建类的对象，然后交给spring管理(注册 IOC 容器)。
   
2) Feign接口被调用时，底层代理对象会将接口中的请求信息通过编码器创建 Request对象，基于此对象进行远程过程调用。
   
3) Feign客户端请求对象会经Ribbon进行负载均衡，挑选出一个健康的 Server 实例（instance）。
   
4) Feign客户端会携带 Request 调用远端服务并返回一个响应。
   
5) Feign客户端对象对Response信息进行解析然后返回客户端。

### 小节面试分析

- 为什么使用feign?(基于Feign可以更加友好的实现服务调用，简化服务消费方对服务提供方方法的调用)。
- @FeignClient注解的作用是什么？(告诉Feign Starter，在项目启动时，为此注解描述的接口创建实现类-代理类)
- Feign方式的调用，底层负载均衡是如何实现的？(Ribbon)
- @EnableFeignCleints 注解的作用是什么？（描述配置类，例如启动类）

## 总结(Summary)

### 重难点分析

- 基于Feign方式的服务调用及基本原理？

### FAQ分析

- Nacos服务负载均衡逻辑及设计实现？(Ribbon)
- 注册中心的核心数据是什么？（服务的名字和它对应的网络地址）
- 注册中心中心核心数据的存取为什么会采用读写锁?(底层安全和性能)
- Nacos健康检查的方式？(基于心跳包机制进行实现)
- Nacos是如何保证高可用的?(重试，本地缓存、集群)
- RestTemplate的基本作用是什么？
- Feign是什么，它的应用是怎样的，feign应用过程中的代理对象是如何创建的（JDK）？
- Feign方式的调用过程，其负载均衡是如何实现？(Ribbon)
- 为什么要负载均衡?(提高系统的并发处理能力,双管齐下,类似银行的各个营业点)
- LoadBalancerClient对象的作用是什么？(基于负载均衡算法从注册中心获取服务实例)
- @LoadBalanced注解作用?(描述RestTemplate对象,让系统底层为RestTemplate对象赋能，对请求过程进行拦截)
- Ribbon是什么，基于Ribbon可以解决什么问题？(一个负载均衡组件，这个组件中提供一套负载均衡算法)
- 你了解哪些负载均衡策略?(基于IRule接口去查看，快捷键ctrl+h)
- 我们如何修改负载均衡策略?(配置文件->例如application.yml，配置类->例如启功类)
- 为什么使用Feign方式的服务调用?(声明式远程调用，优化结构，简化服务调用过程代码的编写)
- 如何基于feign方式实现远程服务调用?(依赖-openfeign，配置，feign接口定义)
- @EnableFeignCleints 注解的作用是什么?(描述配置类，例如启动类,告诉底层启动feign starter组件）
- @FeignClient注解的作用是什么?(告诉Feign Starter，在项目启动时，为此注解描述的接口创建实现类-代理类)
- 如何理解基于Feign方式的远程服务调用？(底层封装了服务调用过程,明修栈道暗度陈仓)
- Feign方式如何实现负载均衡?(底层基于ribbon组件实现)
- Feign接口指向的对象是谁？(代理对象-feign接口的实现类对象)
  
  ![](https://img-blog.csdnimg.cn/08302558653d4446bab12bcddd8ee4e7.png)

- 常用服务发现、服务调用方式有哪些？
  
  ![](https://img-blog.csdnimg.cn/714083c8ac4c4c028caa0ab4315cd238.png)

* 这部分内容中你接触到了哪些设计模式呢?(单例,享元,代理,工厂,模板方法,策略,观察者,…)

