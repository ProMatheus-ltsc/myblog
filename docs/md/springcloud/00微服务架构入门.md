# 微服务架构入门
[[TOC]]

## 微服务简介

### 背景分析

讲微服务之前，我们先分析以下单体应用。所谓单体应用一般是基于idea/eclipse，maven等建一个工程，然后基于SpringBoot，spring，mybatis框架进行整合，接下来再写一堆dao、mapper、service、controller，再加上一些的配置文件，有可能还会引入redis、elasticsearch、mq等其它项目的依赖，开发好之后再将项目打包成一个jar包/war包。然后再将包扔到类似tomcat这样的web服务中，最后部署到公司提供给你的linux服务器上。 接下来，你针对服务提供的访问端口（例如8080端口）发起http请求，请求会由tomcat直接转交给你的spring web组件，进行一层一层的代码调用。对于这样的设计一般适合企业的内部应用，访问量不大，体积比较小，5人以内的团队即可开发和维护。但对于一些大型互联网项目，假如需要10人以上的开发和维护团队，仅频繁的创建代码分支，编写业务功能，然后合并分支，就会出现很多代码冲突。每次解决这些大量的代码冲突，可能就会耗费好几天的时间。基于这样的背景微服务诞生了.

在微服务架构设计中，建议超出需要10人开发和维护的项目要进行系统拆分，就是把大系统拆分为很多小系统，几个人负责一个服务这样每个服务独立的开发、测试和上线，代码冲突少了，每次上线就回归测试自己的一个服务即可，测试速度快了，上线是独立的，只要向后兼容接口就行了，不需要跟别人等待和协调，技术架构和技术版本的升级，几个人ok就行，成本降低，更加灵活了。

### 什么是微服务

微服务架构（MSA）的基础是将单个应用程序拆分成多个独立的小服务，这些服务可以独立开发、部署和运行。这个过程类似将一个大型火车站或机场拆分成多个机场或火车站。如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/42ea5a797618487588c6201fa45016db.png)

这些服务使用轻量级 API 通过明确定义的接口进行通信。这些服务是围绕业务功能构建的，每项服务执行一项功能。由于它们是独立运行的，因此可以针对各项服务进行更新、部署和扩展，以满足对应用程序特定功能的需求。

生活中的微服务，如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/8aa94e04941ba90386ba165fe0bab9fe.png)

程序中的微服务，就是将各个业务系统的共性再进行抽取，做成独立的服务，如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/1190fdf785a3241edd996d3f7e3b1bd7.png)

总之，微服务是分布式系统中的一种流行的架构模型，它并不是银弹，所以，也不要寄希望于微服务构架能够解决所有的问题。微服务架构主要解决的是如何快速地开发和部署我们的服务，这对于一个能够适应快速开发和成长的公司是非常必要的。同时，微服务设计中有很多很不错的想法和理念，通过学习微服务架构我们可以更快的迈向卓越。

## SpringCloud Alibaba微服务解决方案

### 概述

Spring Cloud Alibaba 是Spring Cloud(微服务头牌)的一个子项目，致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。

### 核心组件分析

Spring Cloud Alibaba 默认提供了如下核心功能（先了解）：

- 服务限流降级：
  默认支持 WebServlet、OpenFeign、RestTemplate、Spring Cloud Gateway, RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。
- 服务注册与发现：
  基于Spring Cloud 服务注册与发现标准，借助Nacos进行实现，默认还集成了 Ribbon 的支持。
- 分布式配置管理：
  基于Nacos支持分布式系统中的外部化配置，配置更改时自动刷新。
- 消息驱动能力：
  基于Spring Cloud Stream 为微服务应用构建消息驱动能力。
- 分布式事务：
  使用 `@GlobalTransactional` 注解， 高效并且对业务零侵入地解决分布式事务问题。。
- 分布式任务调度：
  提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker上执行。

### 解决方案架构设计

基于Spring Cloud Alibaba实现的微服务，解决方案设计架构如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0ab978a65db54ad1908ba337d6646eaa.png)

## 构建SpringCloud 聚合项目并进行环境初始化

### 工程结构

微服务项目一般都会采用聚合工程结构，可通过聚合工程结构实现共享资源的复用，简化项目的管理方式。本小节以一个聚合工程结构为案例，讲解微服务架构方案中的maven聚合工程的基本结构，例如：

```bash
GitCGB2108IVProjects (工作区/空项目)
├── 01-sca   //(微服务父工程)
     ├── sca-provider            //服务提供方法
     ├── sca-consumer         //服务消费方法
     ├── sca-gateway            //网关服务
```

### 创建空项目

打开Idea,创建一个空项目(Empty Project),项目名为GitCGB2108IVProjects,例如:

![在这里插入图片描述](https://img-blog.csdnimg.cn/a5acd879efc541a5a38368a9aaeebbad.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/bca2bd868ca84fc280d9818a69b5487b.png)

其中，这个空项目就类似磁盘中的一个空的文件夹，可以将此文件夹作为一个代码工作区。

### 项目初始化配置

第一步:配置maven环境(只要是新的工作区,都要重新配置),注意本地库选择新的位置不要与其它项目共用本地库，因为多个项目所需要依赖的版本不同时，可能会有一些依赖版本的冲突。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1d9a20fa1c62448b845b996026b946d6.png)

说明，这里的本地库名字最要不要选择中文，单词之间也不要有空格。

第二步:配置JDK编译环境

聚合工程在编译时，需要对相关依赖的工程进行一起编译，所以需要做一些配置，例如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/4d434cc0d582401495849b8ddfc159e8.png)

指定一下当前工作区的jdk编译版本，例如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/4ed8539733324bf2bd9952a659485344.png)

第三步:配置工作区中项目编码方式

![在这里插入图片描述](https://img-blog.csdnimg.cn/b6efc511e88c4fbb963eac5334809ad0.png)

### 创建聚合父工程

我们后续在创建微服务工程进行学习时,相关服务依赖版本的管理，公共依赖，项目编译，打包设计等都可以放在此工程下，进行统一的配置，然后实现共享。

第一步:创建父工程模块,例如:

![在这里插入图片描述](https://img-blog.csdnimg.cn/c1bb1381966642e0bd4680eefd50dbd2.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/ec0be2d8ac424b969532c62ac3ff2319.png)

第二步:删除工程中的src目录(父工程不需要这个目录),例如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/730c87cdb51947c1bd77fe4e7c93decf.png)

第三步：修改项目pom.xml文件内容，例如：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <!--当前工程的坐标-->
    <groupId>com.jt</groupId>
    <artifactId>01-sca</artifactId>

    <version>1.0-SNAPSHOT</version>

    <!--有的同学在创建maven工程时,可能会有如下有两句话,这两句话用于指定
    当前项目的jdk编译版本以及运行版本,也可以不指定，后续我们自己通过maven插件方式进行配置-->
    <!--
    <properties>
         <maven.compiler.source>8</maven.compiler.source>
         <maven.compiler.target>8</maven.compiler.target>
    </properties>
    -->
    <!--maven父工程的pom文件中一般要定义子模块,
    子工程中所需依赖版本的管理,公共依赖并且父工程的
    打包方式一般为pom方式-->

    <!--第一步: 定义子工程中核心依赖的版本管理(注意,只是版本管理)-->
    <dependencyManagement>
        <dependencies>
            <!--spring boot 核心依赖版本定义(spring官方定义)-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.3.2.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--Spring Cloud 微服务规范(由spring官方定义)-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.SR9</version>
                <type>pom</type><!--假如scope是import,type必须为pom-->
                <scope>import</scope><!--引入三方依赖的版本设计-->
            </dependency>

            <!--Spring Cloud alibaba 依赖版本管理 (参考官方说明)-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2.2.6.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <!--第二步: 添加子工程的所需要的公共依赖-->
    <dependencies>
        <!--lombok 依赖,子工程中假如需要lombok,不需要再引入-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope><!--provided 表示此依赖仅在编译阶段有效-->
        </dependency>
        <!--单元测试依赖,子工程中需要单元测试时,不需要再次引入此依赖了-->
         <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope><!--test表示只能在test目录下使用此依赖-->
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--其它依赖...-->
    </dependencies>
    <!--第三步: 定义当前工程模块及子工程的的统一编译和运行版本-->
    <build><!--项目构建配置,我们基于maven完成项目的编译,测试,打包等操作,
    都是基于pom.xml完成这一列的操作,但是编译和打包的配置都是要写到build元素
    内的,而具体的编译和打包配置,又需要plugin去实现,plugin元素不是必须的,maven
    有默认的plugin配置,常用插件可去本地库进行查看-->
        <plugins>
            <!--通过maven-compiler-plugin插件设置项目
            的统一的jdk编译和运行版本-->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                 <!--假如本地库没有这个版本,这里会出现红色字体错误-->
                <version>3.8.1</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```

其中，服务核心依赖版本可参考如下网址（涉及到一个兼容性问题，不能随意指定其版本）：

```
https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E
```

### 创建服务提供方模块

创建服务提供方工程，继承01-sca，例如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/03a2dc4ba2b74a0298248176af57362e.png)

### 创建服务消费方模块

创建服务消费方工程，继承01-sca，例如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/d0edd0dc23b14371b5cc14eee4faee49.png)

### 创建API网关服务模块

创建网关工程（这个工程后续会作为API服务访问入口），继承01-sca，例如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0a65a53271c64830abbdb781c722ff11.png)

### 服务关系以及调用关系设计

基于前面章节创建的项目，后续我们会讲解服务的注册，服务的配置，服务之间的调用，负载均衡，限流，熔断，网关等相关知识，现在先了解一个简易结构，例如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/f04c65c16cfd4be4aaa64dcf8b1f2542.png)

我们最终会基于这个结构的设计，实现一个从网关到服务消费方，再从服务消费方到服务提供方的一个调用链路的业务及代码实践过程。

## 总结(Summary)

总之，微服务是一个架构设计方式，此架构中的每个服务(service)都是针对一组功能而设计的，并专注于解决特定的问题。如果开发人员逐渐将更多代码增加到一项服务中，并且导致这个服务变得越来越复杂，就可以将其拆分成多项更小的服务（软件即服务，所有软件对外的表现形式就诗提供一种或多种业务服务）。接下来进行独立的开发、测试、部署、运行、维护。进而更好，更灵活的处理客户端的请求并提高系统的可靠性，可扩展性。在现代大规模企业软件开发中，微服务架构能够帮助开发扩展规模并带来很多长期收益。但是微服务架构并不是随处可用的银弹，如果应用在错误的应用程序类型，微服务架构将弊大于利。希望采用微服务架构的开发团队应该遵循一些最佳实践，并使用一系列可重用的、久经锤炼的设计模式来更好实现你的微服务架构设计。

### 微服务架构诞生的背景

(服务大了太臃肿，要拆成若干个小系统；分而治之~北京一个火车站到多个火车站)

- 为什么需要微服务?(对系统分而治,解决因并发访问过大带来的系统复杂性(例如:业务,开发,测试,升级,可靠性等)
- 微服务设计的特点?(单一职责,独立进程,开发测试效率高,可靠性高,升级难度小,但会带来一定的维护成本)

### 微服务架构解决方案

(大厂基本自研~自己研发各种组件,中小公司用Spring Cloud Netflix,Alibaba,…)

- 微服务解决方案有哪些?(大厂自研,中小企业采用开源Spring Cloud Alibaba,Spring Cloud Netfix等 )

### 微服务架构下Maven聚合项目的创建方式?

(Maven聚合项目~资源复用:extends,import,简化编译,打包,部署方式)

- 微服务设计中需要哪些关键组件(服务的注册,发现,配置,限流降级,访问入口管理,分布式事务管理等)
- 创建聚合工程的目的?(实现工程之间资源的的共享，简化工程管理)
- 如何修改聚合工程中项目的编译和运行版本?(pom.xml:build->plugins->plugin->maven-compiler-plugin)

### 微服务架构入门聚合项目结构分析及创建?

(01-sca,sca-consumer,sca-provider,sca-gateway)



- maven工程中build元素的作用?(定义项目的编译,打包方式)
- maven父工程的packaging元素内的值是什么?(父工程默认打包方式为pom方式)
- maven父工程中dependencyManagement元素的作用是什么?(项目依赖的版本，当前工程或子工程不需要再指定版本)
- Maven父工程中如何统一定义JDK编译和运行版本？（配置maven编译插件：maven-compiler-plugin）
- Maven工程pom.xml文件有删除线怎么解决？（修改idea中maven的配置）

### 练习

> 练习一：公共工程设计及实现

第一步：创建01-sca工程的子工程，工程模块名sca-common，例如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/c9eb92cf6ca14805bf066197f10bc183.png)

第二步：在sca-common模块工程中创建一个工具类com.jt.common.util.StringUtils,并在类中添加一个判断字符串是否为空的静态方法。

```java
package com.jt.common.util;

public class StringUtils {
    /**
     * 通过此方法判定传入的字符串是否为空
     * @param str
     * @return
     */
    public static boolean isEmpty(String str){
        return str==null||"".equals(str);
    }
}

```

第三步：将sca-common工程以依赖的方式添加到sca-provider工程中？

```xml
<dependencies>
    <!--添加springboot web依赖(此依赖中包含了springboot工程需要的很多基础依赖)-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--添加sca-common依赖-->
    <dependency>
        <groupId>com.jt</groupId>
        <artifactId>sca-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>

```

第四步：在sca-provider工程中添加一个springboot启动类，类名为com.jt.ProviderApplication

```java
package com.jt;
import com.jt.common.cache.DefaultCache;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
@SpringBootApplication
public class ProviderApplication{
    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class,args);
    }
}

```

第五步：在sca-provider工程中写一个单元测试类，类全名为com.jt.util.StringTests,并添加单元测试方法，在这个单元测试方法中使用sca-common工程中写的StringUtils类，测试一个字符串是否为空.

```java
package com.jt.util;
import com.jt.common.util.StringUtils;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class StringTests {
    @Test //org.junit.jupiter.api.Test
    void testStringEmpty(){
         String str="";
         boolean empty = StringUtils.isEmpty(str);
         System.out.println(empty);
    }
}

```

> 练习二：熟悉工程中对象的管理以及测试

第一步：在sca-common工程中定义一个com.jt.common.cache.DefaultCache类型.

```java
package com.jt.common.cache;
public class DefaultCache {
}

```

第二步：在sca-provider工程将DefaultCache类型的对象交给spring管理，写到启动类即可。

```java
package com.jt;
import com.jt.common.cache.DefaultCache;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
@SpringBootApplication
public class ProviderApplication{
    @Bean
    public DefaultCache defaultCache(){//将DefaultCache对象交给spring管理
        return new DefaultCache();
    }
    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class,args);
    }
}

```

第三步：在sca-provider工程中定义个单元测试类DefaultCache，并且在类中定义一个
单元测试方法，输出DefaultCache对象的toString方法的返回值。

```java
package com.jt.util;

import com.jt.common.cache.DefaultCache;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class DefaultCacheTests {
    @Autowired //DI
    private DefaultCache defaultCache;
    @Test
    void testDefaultCache(){
        System.out.println(defaultCache.toString());
    }
}
```